Lo primero que hacemos es abrir el gdb con el ejecutable y poner los siguientes códigos:

(gdb) layout asm
(gdb) layout regs
(gdb) br main

Ahora buscamos las funciones que codifican las contraseñas. Esto lo podemos ver en la zona donde salen los nombres entre <>. Lo recomendable es poner un breakpoint en cada una de ellas:

(gdb) br cifradoContr
(gdb) br cifradoCode

Lanzamos el programa con las entradas por teclado de la siguiente forma. Aqui vemos un ejemplo en el que pasaríamos la contraseña "hola" y el código "123"

(gdb) run < <(echo -e hola\\n123\\n)

Cuando llegamos a la primera función llamada cifrado de contraseña lo que podemos ver a partir de la instruccion de <cifradoContr+14> es que comienza un for donde vemos que %ecx es el iterador, el cual se mueve a %rsi en cada iteracción.

Si vamos avanzando con ni vemos que mueve a %edx el valor en la posición %rsi del %rbx que es donde se almacena el valor pasado como parámetro.

Luego más abajo nos damos cuenta que coge el valor de la posición del array de char con la que se esta trabajando y le resta 0x61 y luego lo compara a ver si es mayor de 0x19. El porque hace esto tiene una sencilla explicación. Si miramos la tabla ascii vemos que el numero 0x61 corresponde a la 'a', y si le sumamos 0x19 llegamos al número 0x7A, el cual corresponde a la 'z'. Con la orden ja lo que hace es comparar que el segundo argumento sea mayor que el primero por lo que si %edx es mayor que 0x19 saltaría de nuevo a una nueva interacción del bucle por lo que en esa posición del array de salida se introduciría el mismo elemento de la misma posición del array pasado como parámetro. Ahora la pregunta es por qué lo que se resta es 0x19. La respuesta a esto es sencilla. Si cogemos la tabla ascii vemos que si restaramos los códigos entre el caracter 'a' y 'z', %edx no sería mayor que 0x19, pero si el caracter es menor que 'a' el número negativo en hexadecimal sería más grande que 0x15 porque ja trabaja con datos unsigned. Si el caracter fuera mayor que 'z' también acabaría esa interacción en el for debido a que la resta daría un resultado mayor que 19. Mientras seguimos haciendo ni.

Justo despues de ja vemos que hay una orden sub por lo que resta un valor. En este caso resta 0x4 a %edx. Por lo que si estamos trabajando con la palabra "hola" el primer caracter 'h' se convertiría en 'd'.

Ya vemos que sigue con el bucle hasta que acabe la palabra. Por lo que llegamos a deducir el algoritmo de codificación de la contraseña:

Para el ejemplo hola, la codificación sería la siguiente: 

'h' - 4 = 'd'
'o' - 4 = 'k'
'l' - 4 = 'h'
'a' - 4 = ']' 

Por lo que la palabra que almacenaría nuestro programa sería: dkh].

Ya que tenemos el algoritmo vamos a sacar la palabra codificada del programa y decodificarla:

Vemos donde podemos encontrar la contraseña. En este caso iremos a la llamada a función de strncmp e impriremos %rsi con el siguiente comando:

(gdb) p(char*    )$rsi

Y nos muestra:

"sotbji\n"

Por lo que la contraseña descodificada será:

's' + 4 = 'w'
'o' + 4 = 's'
't' + 4 = 'x'
'b' + 4 = 'f'
'j' + 4 = 'n'
'i' + 4 = 'm'

"wsxfnm"

Ahora en el segundo paso intentaremos conseguir el código. Para conseguir el código lo que hacemos es ir a la función codificarCode. Ejecutamos de nuevo con los nuevos parámetros para la orden run:

run < <(echo -e wsxfnm\\n123\\n)

Nos fijamos esta vez en la función cifradoCode. Esta es más corta. La primera función es lea. Nos tenemos que fijar en el parámetro 0x10(%rdi,%rdi,1). %rdi es el parámetro introducido en la función, que en nuestro caso será 123. Esta parte de la instrucción la podemos traducir como: 

0x10(%rdi,%rdi,1) = 0x10 + %rdi + %rdi*1

El resultado se almacena en %eax. 

La siguiente instrucción es sar. Esta instrucción lo que hace es mover una posición a la derecha los bits. Esta operación se puede ver así o como una operación entre 2 ya que si mueves un bit a la derecha el número se divide entre 2. Por lo que llegamos a la conclusión de que:

sar %eax = %eax = %eax / 2

La última instrucción es de nuevo lea:

lea (%rax,%rax,2),%eax = %rax + %rax*2 = %rax*3

Ya acaba la función, por lo que deducimos la codificación:

Como: 0x10 = 16

16 + 123 + 123*1 = 262
262 / 2 = 131
131*3 = 393

El numero codificado seŕía 393

Ahora buscamos el número del programa para decodificarlo, con la orden:

(gdb) p (int )passcode

Esto nos devuelve "13182". Intentamos decodificar el código:

13182/3 = 4394
4394*2  = 8788
8788-16 = 8772
8788/2  = 4386

El código es 4386. Probamos la contraseña y el código a ver si es correcto.
